<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyblock Crafting Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .container {
            background-color: #2d3748;
            border-radius: 1.5rem;
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.3);
            padding: 2.5rem;
            max-width: 95%;
            width: 700px;
            text-align: center;
            border: 1px solid #4a5568;
        }
        input[type="text"], input[type="number"], button {
            font-size: 1.05rem;
            margin-bottom: 1.25rem;
        }
        button {
            background-color: #4299e1;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            width: 100%;
            padding: 0.85rem 1.75rem;
            border-radius: 0.75rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }

        #results, #craftTreeDisplay {
            background-color: #2c313a;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1.75rem;
            text-align: left;
            border: 1px solid #4a5568;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #results ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #results li {
            padding: 0.6rem 0;
            border-bottom: 1px dashed #4a5568;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }
        #results li:hover {
            background-color: rgba(74, 85, 104, 0.2);
            border-radius: 0.25rem;
        }
        #results li:last-child {
            border-bottom: none;
        }
        .item-name {
            font-weight: bold;
            color: #90cdf4;
            font-size: 1.05rem;
        }
        .item-quantity {
            color: #a0aec0;
            font-size: 1.05rem;
        }
        .error-message {
            color: #fc8181;
            font-weight: bold;
            margin-top: 1rem;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4299e1;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #craftTreeDisplay ul {
            list-style: none;
            padding-left: 1rem;
        }

        #craftTreeDisplay li {
            padding: 0.35rem 0;
            border-bottom: 1px dotted #4a5568;
        }

        #craftTreeDisplay li:last-child {
            border-bottom: none;
        }

        .craft-step-header {
            display: flex;
            align-items: flex-start;
            flex-wrap: nowrap;
            padding: 0.25rem 0;
        }

        .main-content-flex {
            display: flex;
            align-items: flex-start;
            flex-grow: 1;
            justify-content: space-between;
            flex-wrap: nowrap;
        }

        .item-text-content {
            display: flex;
            flex-direction: column;
            flex-shrink: 1;
            min-width: 0;
        }

        .craft-step {
            font-weight: bold;
            color: #63b3ed;
            font-size: 1rem;
        }
        .craft-step-details {
            font-size: 0.95em;
            color: #a0aec0;
            margin-top: 0.2rem;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"] {
            -moz-appearance: textfield;
            appearance: none;
        }

        #autocomplete-list {
            position: absolute;
            border: 1px solid #4a5568;
            border-top: none;
            z-index: 99;
            background-color: #2d3748;
            max-height: 200px;
            overflow-y: auto;
            width: calc(100% - 4rem);
            left: 2rem;
            right: 2rem;
            border-radius: 0 0 0.5rem 0.5rem;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }

        #autocomplete-list div {
            padding: 10px;
            cursor: pointer;
            background-color: #2d3748;
            border-bottom: 1px solid #4a5568;
            text-align: left;
            transition: background-color 0.2s;
        }

        #autocomplete-list div:hover {
            background-color: #4a5568;
        }

        #autocomplete-list div:last-child {
            border-bottom: none;
        }

        #autocomplete-list::-webkit-scrollbar {
            width: 8px;
        }

        #autocomplete-list::-webkit-scrollbar-track {
            background: #2c313a;
            border-radius: 10px;
        }

        #autocomplete-list::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 10px;
            border: 2px solid #2c313a;
        }

        #autocomplete-list::-webkit-scrollbar-thumb:hover {
            background-color: #63b3ed;
        }

        .toggle-arrow {
            cursor: pointer;
            margin-right: 0.5rem;
            font-weight: bold;
            color: #63b3ed;
            user-select: none;
            min-width: 1em;
            text-align: center;
            transition: color 0.2s;
        }
        .toggle-arrow:hover {
            color: #90cdf4;
        }

        .craft-checkbox {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 1.35rem;
            height: 1.35rem;
            border: 2px solid #63b3ed;
            border-radius: 0.35rem;
            background-color: #2c313a;
            cursor: pointer;
            position: relative;
            margin-right: 0.6rem;
            flex-shrink: 0;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .craft-checkbox:checked {
            background-color: #48bb78;
            border-color: #48bb78;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='white'%3e%3cpath fill-rule='evenodd' d='M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z' clip-rule='evenodd'/%3e%3c/svg%3e");
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
        }

        .craft-checkbox:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
        }

        .completed-item .craft-step,
        .completed-item .craft-step-details,
        .completed-item .toggle-arrow {
            color: #a0aec0;
            text-decoration: line-through;
        }

        .quantity-labels-row {
            display: flex;
            justify-content: flex-end;
            width: calc(4.5rem * 2 + 0.5rem);
            margin-left: auto;
            margin-bottom: 0.5rem;
            padding-right: 0.5rem;
            gap: 0.5rem;
        }

        .quantity-label {
            font-size: 0.8rem;
            font-weight: bold;
            color: #90cdf4;
            width: 4.5rem;
            text-align: center;
            flex-shrink: 0;
        }

        .quantity-inputs-row {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
            width: calc(4.5rem * 2 + 0.5rem);
        }

        .current-quantity-input, .packs-quantity-input {
            width: 4.5rem;
            padding: 0.3rem 0.6rem;
            border-radius: 0.35rem;
            background-color: #4a5568;
            border: 1px solid #63b3ed;
            color: #e2e8f0;
            text-align: center;
            font-size: 0.9rem;
            transition: border-color 0.2s, background-color 0.2s;
            flex-shrink: 0;
        }
        .current-quantity-input:focus, .packs-quantity-input:focus {
            border-color: #90cdf4;
            background-color: #2d3748;
            outline: none;
        }
        .current-quantity-input:disabled, .packs-quantity-input:disabled {
            background-color: #3d4654;
            border-color: #3d4654;
            color: #6b7280;
            cursor: not-allowed;
        }

        @media (max-width: 640px) {
            .container {
                padding: 1.5rem;
                border-radius: 1rem;
            }
            input[type="text"], input[type="number"], button {
                font-size: 0.95rem;
                margin-bottom: 1rem;
            }
            button {
                padding: 0.75rem 1.5rem;
                border-radius: 0.5rem;
            }
            #results, #craftTreeDisplay {
                padding: 1rem;
                margin-top: 1rem;
                border-radius: 0.5rem;
            }
            .item-name, .item-quantity {
                font-size: 0.95rem;
            }
            .craft-step-details {
                font-size: 0.85em;
                margin-top: 0.1rem;
            }
            .quantity-labels-row {
                display: none;
            }
            .craft-step-header {
                flex-wrap: wrap;
                align-items: flex-start;
            }
            .main-content-flex {
                flex-direction: column;
                align-items: flex-start;
                flex-grow: 1;
                width: 100%;
                margin-top: 0.25rem;
            }
            .item-text-content {
                width: 100%;
            }
            .quantity-inputs-row {
                width: 100%;
                justify-content: flex-start;
                margin-top: 0.5rem;
            }
            .current-quantity-input, .packs-quantity-input {
                width: 3.5rem;
                padding: 0.2rem 0.4rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold mb-6 text-white">Skyblock Crafting Calculator</h1>

        <div class="mb-4 relative">
            <input type="text" id="itemName" placeholder="Enter item name (type and press TAB for suggestions)"
                   class="w-full px-4 py-3 rounded-lg bg-gray-700 border border-gray-600 text-gray-100
                          focus:outline-none focus:ring-2 focus:ring-blue-400">
            <div id="autocomplete-list" class="hidden"></div>
        </div>
        <div class="mb-4">
            <input type="number" id="itemQuantity" placeholder="Quantity (default 1)" value="1" min="1"
                   class="w-full px-4 py-3 rounded-lg bg-gray-700 border border-gray-600 text-gray-100
                          focus:outline-none focus:ring-2 focus:ring-blue-400 appearance-none">
        </div>
        <button id="calculateBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out" disabled>
            Calculate Resources
        </button>

        <div class="loading-spinner" id="loadingSpinner"></div>

        <div id="results" class="mt-6 p-4 bg-gray-800 rounded-lg text-left">
            <p class="text-gray-400" id="initialMessage">Loading item data for search... Please wait.</p>
            <p class="text-gray-400 mt-2 text-sm">
                **Recipes are fetched live from the NotEnoughUpdates GitHub repository.**
                This requires an-internet connection and may be subject to GitHub's rate limits.
            </p>
        </div>

        <div id="craftTreeDisplay" class="mt-6 p-4 bg-gray-800 rounded-lg text-left hidden">
            <h2 class="text-xl font-bold mb-4 text-white">Crafting Steps:</h2>
            <div class="quantity-labels-row">
                <span class="quantity-label">Items</span>
                <span class="quantity-label">Packs</span>
            </div>
            <div id="craftTreeContent"></div>
        </div>
    </div>

    <script>
        const itemNameInput = document.getElementById('itemName');
        const itemQuantityInput = document.getElementById('itemQuantity');
        const calculateBtn = document.getElementById('calculateBtn');
        const resultsDiv = document.getElementById('results');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const craftTreeDisplay = document.getElementById('craftTreeDisplay');
        const craftTreeContent = document.getElementById('craftTreeContent');
        const initialMessage = document.getElementById('initialMessage');
        const autocompleteList = document.getElementById('autocomplete-list');

        const RECIPES_BASE_URL = 'https://raw.githubusercontent.com/NotEnoughUpdates/NotEnoughUpdates-REPO/master/items/';
        const DISPLAY_NAME_LOOKUP_FILE = 'https://raw.githubusercontent.com/BrSalv2006/Skyblock-Crafting-Calculator/refs/heads/main/skyblock_displayname_map.json';
        const PACK_SIZE = 64;

        let DISPLAY_NAME_LOOKUP = {};
        let ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME = {};
        let currentCraftTreeRoot = null;
        let nodeMap = new Map();

        function normalizeInternalName(name) {
            return name.toUpperCase().trim();
        }

        function cleanDisplayName(name) {
            return name ? name.replace(/§[0-9a-fklmnor]/g, '').trim() : '';
        }

        async function loadDisplayNameLookup() {
            try {
                initialMessage.textContent = 'Fetching item name lookup data...';
                const response = await fetch(DISPLAY_NAME_LOOKUP_FILE);
                if (!response.ok) {
                    throw new Error(`Failed to load display name lookup file: ${response.status} ${response.statusText}`);
                }
                const rawLookup = await response.json();

                for (const displayName in rawLookup) {
                    const internalName = rawLookup[displayName];
                    const cleanedLowerDisplayName = cleanDisplayName(displayName).toLowerCase();
                    DISPLAY_NAME_LOOKUP[cleanedLowerDisplayName] = internalName;
                    ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[internalName] = cleanDisplayName(displayName);
                }

                initialMessage.textContent = 'Item data loaded. Enter an item to calculate.';
                calculateBtn.disabled = false;
            } catch (error) {
                console.error(`Error loading display name lookup: ${error.message}`);
                initialMessage.innerHTML = `<span class="error-message">Error loading item data: ${error.message}. Display name search may not work.</span>`;
                calculateBtn.disabled = false;
            }
        }

        loadDisplayNameLookup();

        async function fetchRecipe(internalName) {
            if (normalizeInternalName(internalName) === "SKYBLOCK_COIN") {
                return {
                    output: "Skyblock Coins",
                    ingredients: [],
                    internalname: "SKYBLOCK_COIN",
                    count: 1,
                    isVanilla: true
                };
            }

            const url = `${RECIPES_BASE_URL}${normalizeInternalName(internalName)}.json`;

            try {
                const response = await fetch(url);

                if (!response.ok) {
                    const displayOutput = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[normalizeInternalName(internalName)] || cleanDisplayName(internalName);
                    return { output: displayOutput, ingredients: [], internalname: normalizeInternalName(internalName), count: 1, isVanilla: false };
                }

                const recipeRecord = await response.json();

                if (!recipeRecord || typeof recipeRecord.internalname !== 'string') {
                    throw new Error(`Invalid recipe data for ${internalName}`);
                }

                const isVanillaItem = recipeRecord.vanilla === true;

                if (isVanillaItem) {
                    const displayOutput = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[recipeRecord.internalname] || cleanDisplayName(recipeRecord.displayname || internalName);
                    return {
                        output: displayOutput,
                        ingredients: [],
                        internalname: recipeRecord.internalname,
                        count: 1,
                        isVanilla: true
                    };
                }

                const ingredientsMap = {};
                let outputCount = 1;

                if (recipeRecord.recipes && Array.isArray(recipeRecord.recipes) && recipeRecord.recipes.length > 0) {
                    for (const primaryRecipe of recipeRecord.recipes) {
                        if (primaryRecipe) {
                            if (primaryRecipe.inputs && Array.isArray(primaryRecipe.inputs)) {
                                primaryRecipe.inputs.forEach(inputString => {
                                    const [ingInternalName, quantityStr] = inputString.split(':');
                                    const quantity = parseInt(quantityStr, 10);
                                    if (ingInternalName && !isNaN(quantity) && quantity > 0) {
                                        ingredientsMap[ingInternalName] = (ingredientsMap[ingInternalName] || 0) + quantity;
                                    }
                                });
                                outputCount = primaryRecipe.count || 1;
                                break;
                            } else if (primaryRecipe.A1 !== undefined || primaryRecipe.A2 !== undefined || primaryRecipe.A3 !== undefined ||
                                       primaryRecipe.B1 !== undefined || primaryRecipe.B2 !== undefined || primaryRecipe.B3 !== undefined ||
                                       primaryRecipe.C1 !== undefined || primaryRecipe.C2 !== undefined || primaryRecipe.C3 !== undefined) {
                                const gridSlots = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'];
                                gridSlots.forEach(slot => {
                                    const ingredientString = primaryRecipe[slot];
                                    if (ingredientString) {
                                        const [ingInternalName, quantityStr] = ingredientString.split(':');
                                        const quantity = parseInt(quantityStr, 10);
                                        if (ingInternalName && !isNaN(quantity) && quantity > 0) {
                                            ingredientsMap[ingInternalName] = (ingredientsMap[ingInternalName] || 0) + quantity;
                                        }
                                    }
                                });
                                outputCount = primaryRecipe.count || 1;
                                break;
                            }
                        }
                    }
                } else if (recipeRecord.recipe && Object.keys(recipeRecord.recipe).length > 0) {
                    for (const slot in recipeRecord.recipe) {
                        const ingredientString = recipeRecord.recipe[slot];
                        if (ingredientString) {
                            const [ingInternalName, quantityStr] = ingredientString.split(':');
                            const quantity = parseInt(quantityStr, 10);
                            if (ingInternalName && !isNaN(quantity) && quantity > 0) {
                                ingredientsMap[ingInternalName] = (ingredientsMap[ingInternalName] || 0) + quantity;
                            }
                        }
                    }
                    outputCount = 1;
                }

                const ingredientsArray = Object.entries(ingredientsMap).map(([ingInternalName, quantity]) => {
                    const display = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[normalizeInternalName(ingInternalName)] || cleanDisplayName(ingInternalName);
                    return { name: display, internalName: ingInternalName, quantity: quantity };
                });

                const displayOutput = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[recipeRecord.internalname] || cleanDisplayName(recipeRecord.displayname || internalName);

                return {
                    output: displayOutput,
                    ingredients: ingredientsArray,
                    internalname: recipeRecord.internalname,
                    count: outputCount,
                    isVanilla: false
                };

            } catch (error) {
                console.error(`Error fetching recipe for ${internalName}:`, error);
                const displayOutput = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[normalizeInternalName(internalName)] || cleanDisplayName(internalName);
                return { output: displayOutput, ingredients: [], internalname: internalName, count: 1, isVanilla: false };
            }
        }

        async function buildCraftTree(itemInternalName, quantityNeeded) {
            const recipeInfo = await fetchRecipe(itemInternalName);
            const nodeId = crypto.randomUUID();
            const node = {
                name: recipeInfo.output,
                internalName: recipeInfo.internalname,
                quantityNeeded: quantityNeeded,
                quantityProducedPerCraft: 1,
                numCraftsRequired: quantityNeeded,
                ingredients: [],
                children: [],
                nodeId: nodeId,
                completed: false,
                isCollapsed: false,
                currentQuantity: 0,
                packsQuantity: 0
            };
            nodeMap.set(nodeId, node);

            if (recipeInfo.ingredients.length === 0) {
                return node;
            }

            const numCrafts = Math.ceil(quantityNeeded / recipeInfo.count);
            node.quantityProducedPerCraft = recipeInfo.count;
            node.numCraftsRequired = numCrafts;
            node.ingredients = recipeInfo.ingredients;

            for (const ingredient of recipeInfo.ingredients) {
                const childNode = await buildCraftTree(ingredient.internalName, ingredient.quantity * numCrafts);
                node.children.push(childNode);
            }

            return node;
        }

        function calculateNetRequiredResources(node, quantityRequiredForNode) {
            const netNeededMap = new Map();

            function traverseAndCalculate(currentNode, currentQuantityRequired) {
                if (currentNode.completed) {
                    return;
                }

                const totalHave = currentNode.currentQuantity + (currentNode.packsQuantity * PACK_SIZE);
                const netOutputNeeded = Math.max(0, currentQuantityRequired - totalHave);

                if (netOutputNeeded <= 0) {
                    return;
                }

                if (currentNode.ingredients.length === 0) {
                    netNeededMap.set(currentNode.name, (netNeededMap.get(currentNode.name) || 0) + netOutputNeeded);
                    return;
                }

                const numCraftsRequired = Math.ceil(netOutputNeeded / currentNode.quantityProducedPerCraft);

                for (const ingredient of currentNode.ingredients) {
                    const quantityForChild = ingredient.quantity * numCraftsRequired;
                    const childNode = currentNode.children.find(child => child.internalName === ingredient.internalName);
                    if (childNode) {
                        traverseAndCalculate(childNode, quantityForChild);
                    } else {
                        netNeededMap.set(ingredient.name, (netNeededMap.get(ingredient.name) || 0) + quantityForChild);
                    }
                }
            }

            traverseAndCalculate(node, quantityRequiredForNode);
            return netNeededMap;
        }


        function renderCraftTree(node, level = 0) {
            let html = `<li>`;
            let uniqueId = `tree-node-${node.nodeId}`;
            const isCompletedClass = node.completed ? 'completed-item' : '';

            html += `<div class="craft-step-header ${isCompletedClass}">`;
            html += `<input type="checkbox" class="craft-checkbox" data-node-id="${node.nodeId}" ${node.completed ? 'checked' : ''}>`;
            if (node.children && node.children.length > 0) {
                html += `<span class="toggle-arrow" data-target-id="${uniqueId}">${node.isCollapsed ? '►' : '▼'}</span> `;
            } else {
                html += `<span class="toggle-arrow" style="visibility: hidden;">►</span> `;
            }
            html += `<div class="item-text-content">`;
            html += `<span class="craft-step">${node.name}</span>`;
            html += `<span class="craft-step-details"> (Need: ${node.quantityNeeded}`;

            if (node.ingredients.length > 0) {
                html += `, Crafts: ${node.numCraftsRequired}`;
                html += `, Yield: ${node.quantityProducedPerCraft} per craft)`;
            } else {
                html += `)`;
            }
            html += `</span>`;
            html += `</div>`;
            html += `<div class="quantity-inputs-row">`;
            html += `<input type="number" class="current-quantity-input" id="have-${node.nodeId}" min="0" value="${node.currentQuantity}" data-node-id="${node.nodeId}" ${node.completed ? 'disabled' : ''}>`;
            html += `<input type="number" class="packs-quantity-input" id="packs-${node.nodeId}" min="0" value="${node.packsQuantity}" data-node-id="${node.nodeId}" ${node.completed ? 'disabled' : ''}>`;
            html += `</div>`;
            html += `</div>`;

            if (node.children && node.children.length > 0) {
                html += `<ul id="${uniqueId}" style="display: ${node.isCollapsed ? 'none' : 'block'};">`;
                for (const child of node.children) {
                    html += renderCraftTree(child, level + 1);
                }
                html += `</ul>`;
            }
            html += `</li>`;

            return html;
        }

        function recalculateAndRenderResources() {
            resultsDiv.innerHTML = '';
            const totalResources = {};
            if (currentCraftTreeRoot) {
                const netNeededMap = calculateNetRequiredResources(currentCraftTreeRoot, currentCraftTreeRoot.quantityNeeded);
                netNeededMap.forEach((quantity, resourceName) => {
                    totalResources[resourceName] = quantity;
                });
            }

            if (Object.keys(totalResources).length === 0) {
                resultsDiv.innerHTML = '<p class="text-gray-400">No base resources found (all items might be marked as completed or you have enough).</p>';
            } else {
                const ul = document.createElement('ul');
                Object.entries(totalResources).sort(([nameA], [nameB]) => nameA.localeCompare(nameB)).forEach(([resourceName, quantity]) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="item-name">${resourceName}</span> <span class="item-quantity">${quantity}</span>`;
                    ul.appendChild(li);
                });
                resultsDiv.appendChild(ul);
            }
        }

        function setNodeAndChildrenCompletion(node, completedStatus) {
            node.completed = completedStatus;
            const listItem = document.querySelector(`[data-node-id="${node.nodeId}"]`).closest('li');
            if (listItem) {
                const headerDiv = listItem.querySelector('.craft-step-header');
                const checkbox = listItem.querySelector('.craft-checkbox');
                const quantityInput = listItem.querySelector('.current-quantity-input');
                const packsInput = listItem.querySelector('.packs-quantity-input');

                if (headerDiv) {
                    if (completedStatus) {
                        headerDiv.classList.add('completed-item');
                    } else {
                        headerDiv.classList.remove('completed-item');
                    }
                }
                if (checkbox) {
                    checkbox.checked = completedStatus;
                }
                if (quantityInput) {
                    quantityInput.disabled = completedStatus;
                    if (completedStatus) {
                        node.currentQuantity = node.quantityNeeded;
                        quantityInput.value = node.quantityNeeded;
                    } else {
                        node.currentQuantity = 0;
                        quantityInput.value = 0;
                    }
                }
                if (packsInput) {
                    packsInput.disabled = completedStatus;
                    node.packsQuantity = 0;
                    packsInput.value = 0;
                }
            }

            for (const child of node.children) {
                setNodeAndChildrenCompletion(child, completedStatus);
            }
        }

        function longestCommonPrefix(strs) {
            if (strs.length === 0) return "";
            if (strs.length === 1) return strs[0];

            let prefix = strs[0];
            for (let i = 1; i < strs.length; i++) {
                while (strs[i].indexOf(prefix) !== 0) {
                    prefix = prefix.substring(0, prefix.length - 1);
                    if (prefix === "") return "";
                }
            }
            return prefix;
        }

        itemNameInput.addEventListener('input', function() {
            const inputValue = this.value.toLowerCase().trim();
            autocompleteList.innerHTML = '';
            autocompleteList.classList.add('hidden');

            if (inputValue.length === 0) {
                return;
            }

            const matchingDisplayNames = [];
            for (const internalName in ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME) {
                const originalDisplayName = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[internalName];
                if (originalDisplayName.toLowerCase().includes(inputValue)) {
                    matchingDisplayNames.push(originalDisplayName);
                }
            }

            matchingDisplayNames.sort();

            if (matchingDisplayNames.length > 0) {
                matchingDisplayNames.forEach(displayName => {
                    const div = document.createElement('div');
                    div.textContent = displayName;
                    div.addEventListener('click', function() {
                        itemNameInput.value = this.textContent;
                        autocompleteList.classList.add('hidden');
                        itemNameInput.focus();
                    });
                    autocompleteList.appendChild(div);
                });
                autocompleteList.classList.remove('hidden');
            }
        });

        itemNameInput.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();

                const inputValue = this.value.toLowerCase().trim();
                autocompleteList.innerHTML = '';
                autocompleteList.classList.add('hidden');

                if (inputValue.length === 0) {
                    return;
                }

                const matchingDisplayNames = [];
                for (const internalName in ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME) {
                    const originalDisplayName = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[internalName];
                    if (originalDisplayName.toLowerCase().includes(inputValue)) {
                        matchingDisplayNames.push(originalDisplayName);
                    }
                }

                matchingDisplayNames.sort();

                if (matchingDisplayNames.length > 0) {
                    const commonPrefix = longestCommonPrefix(matchingDisplayNames);
                    if (commonPrefix.toLowerCase().startsWith(inputValue)) {
                        itemNameInput.value = commonPrefix;
                    }

                    matchingDisplayNames.forEach(displayName => {
                        const div = document.createElement('div');
                        div.textContent = displayName;
                        div.addEventListener('click', function() {
                            itemNameInput.value = this.textContent;
                            autocompleteList.classList.add('hidden');
                            itemNameInput.focus();
                        });
                        autocompleteList.appendChild(div);
                });
                autocompleteList.classList.remove('hidden');
            }
        } else if (e.key === 'Enter') {
            e.preventDefault();
            autocompleteList.classList.add('hidden');
            calculateBtn.click();
        }
        });

        itemNameInput.addEventListener('focus', function() {
            const inputValue = this.value.toLowerCase().trim();
            autocompleteList.innerHTML = '';
            autocompleteList.classList.add('hidden');

            if (inputValue.length === 0) {
                return;
            }

            const matchingDisplayNames = [];
            for (const internalName in ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME) {
                const originalDisplayName = ORIGINAL_DISPLAY_NAMES_BY_INTERNAL_NAME[internalName];
                if (originalDisplayName.toLowerCase().includes(inputValue)) {
                    matchingDisplayNames.push(originalDisplayName);
                }
            }

            matchingDisplayNames.sort();

            if (matchingDisplayNames.length > 0) {
                matchingDisplayNames.forEach(displayName => {
                    const div = document.createElement('div');
                    div.textContent = displayName;
                    div.addEventListener('click', function() {
                        itemNameInput.value = this.textContent;
                        autocompleteList.classList.add('hidden');
                        itemNameInput.focus();
                    });
                    autocompleteList.appendChild(div);
                });
                autocompleteList.classList.remove('hidden');
            }
        });

        document.addEventListener('click', function(e) {
            if (e.target !== itemNameInput && e.target.parentNode !== autocompleteList) {
                autocompleteList.classList.add('hidden');
            }
        });

        calculateBtn.addEventListener('click', async () => {
            const itemNameInputVal = itemNameInput.value.trim();
            const itemQuantity = parseInt(itemQuantityInput.value, 10);

            resultsDiv.innerHTML = '';
            craftTreeContent.innerHTML = '';
            craftTreeDisplay.classList.add('hidden');
            loadingSpinner.style.display = 'block';
            autocompleteList.classList.add('hidden');
            nodeMap.clear();

            if (!itemNameInputVal) {
                resultsDiv.innerHTML = '<p class="error-message">Please enter an item **INTERNAL NAME** or **DISPLAY NAME**.</p>';
                loadingSpinner.style.display = 'none';
                return;
            }

            if (isNaN(itemQuantity) || itemQuantity <= 0) {
                resultsDiv.innerHTML = '<p class="error-message">Please enter a valid quantity (a positive number).</p>';
                loadingSpinner.style.display = 'none';
                return;
            }

            try {
                let initialInternalName = normalizeInternalName(itemNameInputVal);

                const cleanedInput = cleanDisplayName(itemNameInputVal).toLowerCase();
                if (DISPLAY_NAME_LOOKUP[cleanedInput]) {
                    initialInternalName = DISPLAY_NAME_LOOKUP[cleanedInput];
                }

                const initialRecipeInfo = await fetchRecipe(initialInternalName);

                if (initialRecipeInfo.internalname !== initialInternalName) {
                     resultsDiv.innerHTML = `<p class="error-message">
                        Recipe for "${itemNameInputVal}" not found.
                        Please ensure you've entered the correct **INTERNAL NAME** (e.g., TITANIUM_DRILL_1)
                        or a recognized **DISPLAY NAME** (e.g., Aspect of the End)
                        and that its corresponding JSON file (e.g., \`/items/TITANIUM_DRILL_1.json\`) exists
                        and is accessible on the NotEnoughUpdates GitHub repository.
                        <br>
                        **Check your browser's console (F12 -> Network/Console tabs) for specific errors (e.g., 404 Not Found).**
                     </p>`;
                     loadingSpinner.style.display = 'none';
                     craftTreeDisplay.classList.add('hidden');
                     return;
                }

                if (initialRecipeInfo.ingredients.length === 0 && initialRecipeInfo.isVanilla === false) {
                    resultsDiv.innerHTML = `<p class="error-message">
                        The item "${cleanDisplayName(initialRecipeInfo.output)}" is not craftable or its recipe is unknown.
                        Please check the recipe definition in its JSON file on GitHub.
                    </p>`;
                    loadingSpinner.style.display = 'none';
                    craftTreeDisplay.classList.add('hidden');
                    return;
                }

                currentCraftTreeRoot = await buildCraftTree(initialInternalName, itemQuantity);

                recalculateAndRenderResources();

                if (currentCraftTreeRoot) {
                    craftTreeContent.innerHTML = `<ul>${renderCraftTree(currentCraftTreeRoot)}</ul>`;
                    craftTreeDisplay.classList.remove('hidden');

                    attachCraftTreeListeners();
                }

            } catch (error) {
                console.error(`Error calculating resources: ${error.message}`);
                resultsDiv.innerHTML = `<p class="error-message">An unexpected error occurred: ${error.message}. Please check your browser's console for details.`;
            } finally {
                loadingSpinner.style.display = 'none';
            }
        });

        function attachCraftTreeListeners() {
            craftTreeContent.querySelectorAll('.toggle-arrow').forEach(arrow => {
                arrow.addEventListener('click', function(event) {
                    event.stopPropagation();
                    const targetId = this.dataset.targetId;
                    const targetUl = document.getElementById(targetId);
                    if (targetUl) {
                        const node = nodeMap.get(targetId.replace('tree-node-', ''));
                        if (node) {
                            node.isCollapsed = !node.isCollapsed;
                            targetUl.style.display = node.isCollapsed ? 'none' : 'block';
                            this.textContent = node.isCollapsed ? '►' : '▼';
                        }
                    }
                });
            });

            craftTreeContent.querySelectorAll('.craft-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const nodeId = this.dataset.nodeId;
                    const node = nodeMap.get(nodeId);
                    if (node) {
                        setNodeAndChildrenCompletion(node, this.checked);
                        recalculateAndRenderResources();
                    }
                });
            });

            craftTreeContent.querySelectorAll('.current-quantity-input').forEach(input => {
                input.addEventListener('input', function() {
                    const nodeId = this.dataset.nodeId;
                    const node = nodeMap.get(nodeId);
                    if (node) {
                        node.currentQuantity = Math.max(0, parseInt(this.value, 10) || 0);
                        recalculateAndRenderResources();
                    }
                });
            });

            craftTreeContent.querySelectorAll('.packs-quantity-input').forEach(input => {
                input.addEventListener('input', function() {
                    const nodeId = this.dataset.nodeId;
                    const node = nodeMap.get(nodeId);
                    if (node) {
                        node.packsQuantity = Math.max(0, parseInt(this.value, 10) || 0);
                        recalculateAndRenderResources();
                    }
                });
            });
        }
    </script>
</body>
</html>